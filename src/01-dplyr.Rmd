---
title: "dplyr"
subtitle: "Fundamentos lenguajes: R"
author: "Alberto Torres Barrán y Irene Rodríguez Luján"
date: "`r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: ["default", "custom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      beforeInit: "macros.js"
    includes:
      before_body: mathjax.html
    keep_md: true
---

```{r setup, include=FALSE}
library(tidyverse)
library(forcats)
library(lubridate)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

<!-- util: https://atrebas.github.io/post/2019-03-03-datatable-dplyr/ -->

## Tidy Data

- El 80% del tiempo del análisis de datos se pasa limpiando y preparando datos (Dasu and Johnson 2003).
- Una vez cargados los datos, es conveniente estructurarlos de forma que el procesado posterior sea lo más sencillo posible.
- Una estructura muy común son los datos ordenados o *tidy data*.
- Hadley y Wickhan (2014) los definen como aquellos donde:
  1. Cada variable forma una columna.
  2. Cada observación o muestra forma una fila.
  3. Cada tipo de unidad de observación forma una tabla.
- El paquete `dplyr` ayuda a generar datos ordenados así como transformarlos y analizarlos de forma eficiente. Algunos ejemplos de manipulaciones de datos con dplyr:
<!--  + Cambiar las dimensiones de los datos (formatos *long* y *wide*). -->
  + Seleccionar subconjuntos de filas y/o columnas.
  + Agrupar datos.
  + Calcular diferentes estadísticos sobre datos (posiblemente agrupados).
  + Generar nuevas variables.
  + Combinar/cruzar tablas.

---

## Introducción

- Implementa una gramática para realizar operaciones básicas con data frames.
- Muy eficiente.
- Operaciones principales: 
  + `slice`: Selecciona filas por su posición.
  + `filter`: Selecciona filas por condición.
  + `select`: Selecciona variables (columnas) de un dataframe.
  + `arrange`: Ordena las filas de un dataframe.
  + `mutate`: Añade nuevas variables(columnas) al dataframe como combinación de las ya existentes.
  + `summarize`: Colapsa el dataframe a una única fila.
- Cada una de estas operaciones realiza una tarea concreta. Esto simplifica la legibilidad del código.
- Estas operaciones se pueden componer para realizar otras más complejas utilizando **pipelines** (`%>%`).
```{r, eval=F}
iris %>% 
  select(Sepal.Width) %>%
  arrange(Sepal.Width)
```


---


## Tibbles

- Las tablas en dplyr (tibbles) son del tipo `tbl`.
- La clase `tbl` es una ["redefinición moderna"](https://blog.rstudio.com/2016/03/24/tibble-1-0-0/) de `data.frame`: mantiene lo que es efectivo de `data.frame` y elimina lo que no.
- **¿Qué diferencia este tipo de datos de un data.frame?**
  + La impresión de los datos es diferente.
  + Tibbles son estrictos en cuanto a la selección de columnas.
  + La selección de filas y/o columnas en tibbles siempre devuelve otro tibble.

- Se puede crear una tabla tibble con la función `tbl_df`:
```{r,eval=F}
iris_tbl <- tbl_df(iris)
is.tbl(iris)
is.tbl(iris_tbl)
is.data.frame(iris)
is.data.frame(iris_tbl)
```

---

## Funciones básicas

- Las funciones vistas para data.frames `head`, `tail`, `View`, `dim`, `nrow`, `ncol`, `rownames`, `colnames`, `str`, `summary` son válidas también con tablas de tipo `tbl`.
- Además, `dplyr` tiene la función `glimpse` que muestra una visión compacta del dataframe.
```{r,eval=T}
glimpse(iris)
```


---
  
## slice

Selecciona filas por su posición

```{r, echo = TRUE}
# con indices positivos
slice(mpg, 1:5)

# descartar filas usando indices negativos
slice(mpg, -6:-234)
```

---

## filter

Selecciona filas por condiciones.
```{r, echo=T}
filter(mpg, model == "a4")
```

---

## Operadores lógicos

- Con la función `filter` se pueden seleccionar filas por condiciones lógicas.
- R implementa las operaciones lógicas "estándar" (negación `!`, and `&` y or `|`), además de otras operaciones lógicas muy útiles para la manipulación de datos.


```{r, echo=FALSE, message=TRUE, warning=TRUE, out.width="100%"}
knitr::include_graphics("img/operadores_logicos.png")
```


- El resultado de todas estas operaciones son valores lógicos `TRUE` (`T`) o `FALSE` (`F`) y pueden utilizarse para el filtrado de filas y columnas.

---

## filter (cont.)

- Se pueden combinar multiples condiciones separadas por `,` (and lógico)
```{r, echo=T, eval=F}
filter(mpg, model == "a4", cyl >= 5)
```

- También se puede usar explicitamente el operador `&`.
```{r, echo=T, eval=F}
filter(mpg, model == "a4" & cyl >= 5)
```

- En el caso del or lógico es obligatorio el uso del operador `|`.
```{r, echo=T, eval=F}
filter(mpg, model == "a4" | model == "mustang")
```

- Se pueden usar algunas de las funciones lógicas anteriores
```{r, eval=F}
filter(mpg, model %in% c("tiburon","new beetle"))
```

---

## Otras funciones para seleccionar filas

- `distinct`: Eliminar filas duplicadas (todas las columnas deben ser idénticas)
```{r,eval=F}
mpg2 <- rbind(mpg, slice(mpg,1))
dim(mpg2)
nodup <- distinct(mpg2)
dim(mpg)
```

- `sample_frac`: Seleccionar aleatoriamente una proporción de las filas.

```{r,eval=F}
sample_frac(mpg, 0.5, replace=T)
```

- `sample_n`: Seleccionar aleatoriamente un número de filas.
```{r,eval=F}
sample_n(mpg, 10, replace=F)
```

- `top_n`: Seleccionar y ordenar el top n de entradas.
```{r,eval=F}
top_n(mpg,2,displ)
```

---

## Select

- Seleccionar variables (columnas) de un data frame.

```{r, echo=T}
select(mpg, model, displ, cyl)
```

---
## Select (cont.)
- Con un `-` se ignoran variables.
```{r, echo=T}
select(mpg, -manufacturer)
```


---

## Select (cont.)

- Puesto que las variables están ordenadas, se puede seleccionar un rango con `:`

```{r, echo=T}
select(mpg, model:trans)
```

---

## Select - Funciones auxiliares 

- Las siguientes funciones se pueden usar dentro de `select()` para seleccionar variables en base a sus nombres.

  + `starts_with()`: empiezan con un prefijo
  + `ends_with()`: terminan con un sufijo
  + `contains()`: contienen una string
  + `matches()`: concuerdan con una expresión regular
  + `num_range()`: rango numérico como "X01", "X02", "X03"
  + `one_of()`: selecciona columnas cuyo nombre está dentro del grupo de nombres.

- Ejemplo: seleccionar variables cuyo nomble contiene el caracter 'c'.
```{r,eval=T}
glimpse(select(mpg,contains("c")))
```

---

## arrange

- Ordena las filas de un data frame por el valor de una o varias columnas.
- Por defecto ordena de menor a mayor (orden ascendente), pero es posible utilizar la función `desc` sobre el nombre de la variable para ordenar descendentemente.
```{r, echo=T}
arrange(mpg, desc(year), cyl)
```

---

## mutate

- Añade nuevas variables (columnas) al data frame como combinación de las ya existentes.

```{r, echo=T}
glimpse(mutate(mpg, avg_mpg = (cty+hwy)/2))
```

---

## mutate (cont.)

- Es posible crear más de una variable en la misma llamada separando cada nueva variable con `,`.

```{r, echo=T}
glimpse(mutate(mpg, avg_mpg = (cty+hwy)/2, twice_cyl=2*cyl))
```

---

## Otras funciones para crear nuevas variables

- `transmute`: Calcula una o más columnas nuevas y elimina las columnas originales.
```{r,eval=T}
glimpse(transmute(mpg, avg_mpg = (cty+hwy)/2))
```


---

## Otras funciones para crear nuevas variables (cont.)


- `mutate_all`: Aplica una función a todas las columnas. Se aplica la función a cada columna individualmente.
```{r,eval=F}
# todas las columnas de tipo caracter
mutate_all(mpg,as.character)
```
- `mutate_at`: Aplica una función a un subconjunto de columnas pasadas como argumento. Se aplica la función a cada columna individualmente.
```{r,eval=F}
glimpse(mutate_at(mpg,c("displ","year","cyl","cty","hwy"),min))
```
- `mutate_if`: Aplica una función a todas las columnas que cumplen una condición lógica especificada. Se aplica la función a cada columna individualmente.
```{r,eval=F}
glimpse(mutate_if(mpg,is.numeric,min))
```

---

## Algunas funciones útiles para generar nuevas columnas

<center>
```{r, echo=FALSE, message=TRUE, warning=TRUE, out.width="80%"}
knitr::include_graphics("img/mutate_funciones2.png")
```
</center>



---

## Operadores y funciones aritméticas

- R implementa los operadores aritméticos habituales 
    + suma `+`
    + resta `-`
    + multiplicación `*`
    + división `/`
    + exponenciación `^`
    + división entera `%/%`
    + módulo (resto) `%%`

- También las funciones aritméticas comunes: `log()`, `exp()`, `sin()`, `cos()`, `tan()`, `cumsum()`, `cumprod()`, `abs()`, `sqrt()`, `round()`, `ceiling()`, `floor()`, `trunc()`, ...

- Operan sobre vectores (columnas de un data frame) elemento a elemento.

---

## summarize

Colapsa el data frame a una única fila

```{r, echo=T}
summarize(mpg, max_cyl = max(cyl), avg_cty = mean(cty), min_year = min(year))
```

---

## Funciones de agregación

- Las funciones más comunes para usar dentro de `summarize()` son: 
    + Aritméticas: `prod()`, `sum()`
    + Centralidad: `mean()`, `median()`
    + Dispersión: `sd()`, `var()`, `mad()`
    + Rango: `max()`, `min()`, `quantile()`
    + Posición: `first()`, `last()`, `nth()`
    + Lógicas: `any()`, `all()`
    + *Conteo*: `n()`, `n_distinct()` (solo se pueden usar dentro de `summarize()`)
    
- Todas reducen un vector de números a un único resultado

---

## Concatenación de funciones

- Todas las funciónes de `dplyr` toman como primer argumento un data frame y devuelven otro data frame
- Se pueden aplicar de manera consecutiva:

```{r, echo=T, eval=F}
arrange(select(filter(mpg, model == "a4"), model, year), year)

arrange(
  select(
    filter(mpg, model == "a4"), 
    model, year
  ), 
  year
)
```

---

## Concatenación de funciones (cont.)

-Otra opción:
```{r, echo=T, eval=F}
df1 <- filter(mpg, model == "a4")
df2 <- select(df1, model, year)
df3 <- arrange(df2, year)
```

- Habitualmente no nos interesan los valores intermedios, solo el resultado final

---

## Operador "tubería" (*pipe*)

- La sintaxis es `%>%` y permite reescribir el código anterior como

```{r, echo=T, eval=F}
mpg %>%
  filter(model == "a4") %>%
  select(model, year) %>%
  arrange(year)
```

- En general el codigo `df %>% foo()` es equivalente a `foo(df)`
- Esto permite concatenar funciones sin almacenar resultados intermedios y siguiendo el orden lógico

---

## Operaciones agrupadas

- La función `group_by()` convierte un data frame en otro agrupado por una o más variables
- En los data frames agrupados todas las operaciones anteriores se realizan "por grupo"
- `ungroup()` elimina la agrupación

---

## Operaciones agrupadas (cont.)

- `slice()` los indices son relativos al grupo
- `select()` mantiene siempre las variables agrupadas, aunque no se indique explicitamente
- `arrange()` ordena en primer lugar por las variables agrupadas

---

## summarize con group_by

Un `summarize()` sobre un data frame agrupado devuelve otro con tantas filas como grupos (valores distintos de la/s variable/s usadas para agrupar)

```{r, echo=T}
mpg %>%
  group_by(cyl) %>%
  summarize(avg_cty = mean(cty))
```

---

## mutate con group_by

Un `mutate()` sobre un data frame agrupado devuelve siempre otro data frame con el mismo número de filas que el original

```{r, echo=T}
mpg %>%
  group_by(cyl) %>%
  mutate(avg_cty = mean(cty))
```

---

## joins

- La librería `dplyr` implementa funciones para unir data frames: `inner_join()`, `left_join()`, `right_join()` y `full_join()`

- Diagrama de Venn [R for Data Science]
<center>
![Diagrama de Venn](join-venn.png)
</center>

---

## Equivalencia con SQL

| dplyr                       | SQL                                            | 
|-----------------------------|------------------------------------------------|
|`inner_join(x, y, by = "z")`	| `SELECT * FROM x INNER JOIN y USING (z)`       |
|`left_join(x, y, by = "z")`	| `SELECT * FROM x LEFT OUTER JOIN y USING (z)`  |
|`right_join(x, y, by = "z")` |	`SELECT * FROM x RIGHT OUTER JOIN y USING (z)` |
|`full_join(x, y, by = "z")`  |	`SELECT * FROM x FULL OUTER JOIN y USING (z)`  |

[R for Data Science]

---

## Ejemplo

```{r}
t4a <- gather(table4a, key = "year", value = "cases", num_range("", 1999:2000))
t4b <- gather(table4b, key = "YEAR", value = "population", `1999`:`2000`)
inner_join(t4a, t4b, by=c("year" = "YEAR", "country"))
```

---

## Operar en múltiples columnas

- dplyr tiene [variantes](https://dplyr.tidyverse.org/reference/scoped.html) de sus funciones principales que operan sobre múltiples columnas
- La selección de columnas puede ser:
    + Todas, funciones que terminan en `_all`
    + Con un predicado, funciones que terminan en `_if`
    + Vector con nombres, posiciones o función [`vars()`](https://dplyr.tidyverse.org/reference/vars.html)

---

```{r}
summarize_all(mpg, funs(sum(is.na(.))))
```

```{r}
mutate_if(mpg, is.numeric, log)
```
